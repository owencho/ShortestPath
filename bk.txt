/*
Node * shortestPath(NetworkNode * nNode){
    List * linkList;
    Node*root,smallestNode;
    //first time
    linkList=getIteratorOfLinks(&nNode);
    root = findNearestNode(&nNode,linkList); //generate AvlTree with cost (not shortest path yet)
    //second time
    for(root != NULL){
        nextNode= avlRemoveSmallest(root,(compare)graphCompare);
        //function to detect the shortestPath
    }
    return root;
*/


Node * findNearestNode(NetworkNode * node, List * linkList){
    Node * root;
    ListItem * listItem;
    Link linkData;
    GraphPath * gNode;
    ShortestPath sPath;
    resetCurrentListItem(linkList);
    while(listItem !=NULL) {
        listItem = getNextListItem(linkList);
        &linkData = listItem->data;
        createShortestPath(&sPath, &linkData);
        createGraphPath(gNode,&sPath);
        root = avlAdd(root,gNode,(compare)graphCompare);
    }
    return root;
}

*/
/**
*               3          4
*         (A)--------(B)--------(E)                (D)2
*        1 \     7 /   \ 5     /                   / \
*           \    /      \    / 7     -->       1(A)  (B)7
*            (C)---------(D)
*                   2
**/
//at C is A B D
void test_findNearestNode(void){
    outList=addListItem(&linkList,&itemA);
    outList=addListItem(outList,&itemB);
    root=findNearestNode(&nodeC,outList);

}

/*
GraphPath* findNearestNode(GraphPath* graphRoot,NetworkNode * node){
    Node * root;
    List * nearestNodelinkList;
    List * pathLinkList;
    ListItem * listItem;
    Link * linkItemData;
    Node * inputNode;
    root = (Node *)graphRoot;
    nearestNodelinkList= getIteratorOfLinks(node);   //retreive the link list
    resetCurrentListItem(nearestNodelinkList);      // reset the linkList

    while(nearestNodelinkList->current !=NULL) {
        listItem = getNextListItem(nearestNodelinkList);
        linkItemData = (Link*)listItem->data;    //retreive the data with cost, head , tail
      //  linkItemData -> cost = linkItemData -> cost + currentPointingNode->value->pathCost;
        if(linkItemData->head->marked ==0 ){
            //pathLinkList = compareShortestPath(GraphPath * currentPointingNode,GraphPath * rootTree,Link * linkItemData)
            //compare inside the working AVL tree see there is any shorter path (then if yes overwrite linkItemData and input PathLink)
            //compareShortestPath(GraphPath * root,Link * linkItemData)
            // pathLink(Link * linkItemData)
            //graphNode value points to shortestPath struct
            gNode =createGraphPath(createShortestPath(linkItemData,pathLinkList));
            root = avlAdd(root,(Node*)gNode,(Compare)graphCompare);
            return NULL; // remember to remove
        }
    }
    return (GraphPath*)root;
}

*/

ShortestPath* createShortestPath(Link * linkItemData, List * pathLinks){
    ShortestPath* sPath = (ShortestPath *)malloc(sizeof(ShortestPath));
    sPath->dst = linkItemData->head;
    sPath->src = linkItemData->tail;
    sPath->pathCost = linkItemData->cost;
    sPath->pathLinks = pathLinks;
    return sPath;
}

Link* createLinkFromShortestPath(ShortestPath * sPath){
    Link* linkItemData = (Link *)malloc(sizeof(Link));
    linkItemData->head= sPath->dst ;
    linkItemData->tail= sPath->src ;
    linkItemData->cost= sPath->pathCost ;
    return linkItemData;
}

List* createLinkListForShortestPath(NetworkNode * head,NetworkNode * tail,int cost){
    List * linkList = (List *)malloc(sizeof(List));
    Link *listItemData= (Link *)malloc(sizeof(Link));
    ListItem newListItem;
    listItemData->head =head;
    listItemData->tail =tail;
    listItemData->cost =cost;
    newListItem.data = (void*)listItemData;
    linkList->head =NULL;
    linkList->tail =NULL;
    linkList->count =0;
    linkList->current =NULL;
    linkList=listAddItemToHead(linkList,&newListItem);
    return linkList;
}

